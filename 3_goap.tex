\chapter{Środowisko GOAP}
% TODO
% Podstawowe aspekty GOAP, pomysłodawca, zastosowania w grach komputerowych
% Opis struktury GOAP: cele, akcje, stan świata, graf
% Zastosowanie goap w robotyce, RGOAP, Felix Kolbe
% GOAP a model BDI

Środowisko GOAP to system planowania akcji, umożliwiający tworzenie w czasie rzeczywistym automatów skończonych wykorzystywanych do sterowania bohaterami niezależnymi w grach czasu rzeczywistego. 

\section{Agenci w grach komputerowych}

Rozwijaniem naturalnej interakcji między ludźmi a programami zajmuje się nie tylko robotyka społeczna, ale także twórcy gier komputerowych. Sztuczna inteligencja jest jednym z najważniejszych elementów rozgrywki. Gracze oczekują, że bohaterowie niezależni (ang. NPC – non-player character) będą zachowywać się, jak gdyby sterowali nimi ludzie. Podobne wymagania stawiane są robotom społecznym, dlatego zasadnym jest zapewnienie przepływu technologii.

Branża gier jest źródłem ciągłych innowacji, ponieważ różnorodność i oryginalność jest kluczem sukcesu finansowego. Zainteresowanie klientów i inwestorów przyczyniło się do rozwoju dziedzin elektroniki nie związanych bezpośrednio z programowaniem, czego przykładem może być opracowanie kamery głębokości Kinect wykorzystywanej obecnie w robotyce. Gry generując duży popyt na sprzęt komputerowy przyspieszyły rozwój procesorów i kart graficznych.  

\subsection{Sterowanie bohaterami niezależnymi a model BDI}
Istnieje wiele gatunków gier – gry turowe, np. strategiczne lub logiczne, czy gry czasu rzeczywistego, np. tzw. shootery lub gry fabularne. Każda z nich wymaga innego podejścia przy projektowaniu podsystemu sterowania agenta. Robot społeczny działa w dynamicznym, niedeterministycznym środowisku, dlatego najłatwiej zastosować technologie z gier czasu rzeczywistego.

Celem gry jest zazwyczaj zrealizowanie jakiejś misji lub kolekcjonowanie osiągnięć (ang. achievement). Niezależnie od gatunku gry, działanie NPC powinno sprawiać wrażenie celowego, a więc być zorientowane na realizację zadań. Wielu twórców, celowo lub nieświadomie, korzysta z elementów modelu BDI. Istniejące rozwiązania można wykorzystać przy tworzeniu implementacji agenta BDI.
Często jednak biblioteki nie są napisane na tyle uniwersalnie, aby móc zastosować je bezpośrednio w robotyce i konieczne jest określenie zakresu zastosowań technologii.

Studio Monolith podczas rozwoju strzelanki pierwszoosobowej (ang. FPS – first-person shooter) o tytule F.E.A.R, spotkało się z problemem koordynowania zachowania grupy bohaterów niezależnych walczących przeciw graczowi. Postaci powinny kryć się przez ogniem przeciwnika, w przypadku wyczerpania amunicji zaatakować innym rodzajem broni lub zbliżyć się, aby skuteczniej zadawać obrażenia.

Dzięki zaproponowanemu rozwiązaniu były w stanie zastawiać zasadzki lub wykorzystywać przewagę ukształtowania terenu. W niektórych przypadkach, gdy NPC uznał, że wygrana nie jest możliwa, uciekał z pola bitwy i już więcej się nie pojawiał, co było nowatorskim rozwiązaniem.

% \subsection{Bohaterowie niezależni jako agenci CERT}
\subsection{Porównanie robotów społecznych i bohaterów niezależnych jako agentów CERT}
Aby określić możliwość zastosowania technologii z gier komputerowych w robotyce należy porównać problemy i rozwiązania pojawiające się tych dziedzinach.

Przede wszystkim agenty będą różnić się od siebie sposobem zdobywania wiedzy. Robot nie ma bezpośrednich informacji o stanie świata, musi wykorzystać sygnały z czujników (rzeczywistych receptorów), a następnie modelować otoczenie i estymować parametry (używając wirtualne receptory). NPC może pobierać dane nieobarczone niepewnością bezpośrednio z silnika gry, stanowiącego element podsystemu komunikacji T. 

Jednak mimo tej różnicy w obu przypadkach można zastosować podobny sposób reprezentacji wiedzy. Agent powinien dysponować "osobistym" stanem wiedzy o świecie, posiadać prywatne cele i swój charakter. Stan wiedzy może być jednak uwspólniony – wielu agentów może wymieniać między sobą informacje z wykorzystaniem podsystemu komunikacji (silnik w przypadku gry, lub np. ROS w przypadku robotów).

Koszt jednostkowy robota zazwyczaj jest bardzo wysoki, często pracuje samodzielnie. W grze może pojawić się bardzo wiele postaci. Aby nie były monotonne konieczne jest nadanie im różnych cech charakteru. Można to zrobić przypisując im różne kompetencje lub dostępne akcje, na przykład jeden z NPC może być liderem swojej grupy. Mając dostęp do wielu robotów można projektować ich zachowanie z myślą o różnorodnych rolach, jakie mogą pełnić. Jednak pracując z tylko jednym robotem ograniczanie jego możliwości, poprzez usuwanie niektórych modułów może być kosztowne.

Roboty w przypadku interakcji, ze względu na obecność w ich otoczeniu ludzi, powinny komunikować swoje działania bezpośrednio, aby człowiek mógł je analizować i przewidywać. W przeciwnym wypadku zachowanie może być niezrozumiałe dla odbiorcy pogarszając jego relację z robotem. Gry komputerowe koncentrują się zazwyczaj na rywalizacji z graczem, więc informacje mogą być przekazywane niejawnie w celu zwiększenia poziomu trudności.

Przy transferze rozwiązań należy uwzględnić, że w robotyce podsystemy E i R powinny przejąć wiele kompetencji realizowanych w grach przez podsystem komunikacji.

% \subsection{Istniejące rozwiązanie}


\section{Automat skończony}

Popularne zarówno w grach jak i robotyce jest wykorzystanie automatów skończonych (ang. FMS – skończone maszyny stanów). Automat skończony jest matematycznym modelem dynamicznego obiektu o dyskretnych stanach. Pozwala na tworzenie podsystemu sterowania agenta.

Działania agenta są rozpisywane jako scenariusze w postaci grafu skierowanego (diagramu stanów). Wierzchołki grafu reprezentują dostępne stany. Jeden ze stanów (początkowy) jest aktywowany jako pierwszy. Przy aktywacji stanu wywoływana jest funkcja (pozwalająca na realizację zadania przez agenta) zwracająca pewne wyjście. Wyjścia przypisane są krawędziom grafu, które łączą poprzedni stan z następnym, aktywując go. Jeżeli w grafie żadne dwa wierzchołki nie są połączone dwukrotnie w tym samym kierunku, to graf ten można przedstawić za pomocą tzw. macierzy przejść.

W maszynie stanów nie wszystkie krawędzie muszą być podłączone z obu stron do wierzchołków. Można w ten sposób okreslić wejścia oraz wyjścia całego automatu. Stany podłączone do wejść mogą być stanami początkowymi. Stany posiadające wyjścia niepodłączone do żadnego kolejnego stanu są nazywane końcowymi. Pozwala to na traktowanie całego automatu jako "czarnej skrzynki", zapewniając modułowość – automat posiada taki sam inferfejs jak pojedyczny stan. Dzięki temu automaty sterujące agentami mogą być wielopoziomowe. Skomplikowane działania rozpisywane są jako automaty, wykorzystywane później w taki sam sposób, jak atomowe stany.

\subsection{Klasyfikacja automatów skończonych}

Istnieją automaty deterministyczne oraz niedeterministyczne. Każdy automat niedeterministyczny można sprowadzić do automatu deterministycznego. Zazwyczaj powoduje to utworzenie wykładniczo większego automatu, jest więc niepraktyczne. Automaty niedeterministyczne są trudniejsze w implementacji, ale są ciekawsze z punktu widzenia robotyki społecznej, ponieważ pozwalają łatwiej uzyskać większą różnorodność w działaniu robota.

W podstawowej wersji automat może mieć aktywowany tylko jeden stan, ale można zaproponować rozszerzenie pozwalające na uruchomienie kilku stanów symultanicznie. Taki automat skończony jest używany przy sterowaniu robotem NAO w programie Choreographe.

\subsection{Automaty skończone przy sterowaniu agentami czasu rzeczywistego}

Programując scenariusze agentów pracujących w czasie rzeczywistym zasadnym jest przyjęcie pewnych konwencji. Każde działanie agenta powinno mieć określone warunki PRE i POST. Prowadzi to do określenia trzech "domyślnych stanów" agenta: 
\begin{itemize}
\setlength\itemsep{-0.4em}
    \item Gdy pożądany cel nie może być określony (warunki PRE nie są spełnione i nie można nic z tym zrobić), agent powinien czekać (stan bezczynny, ang. \textit{idle}). 
    \item Gdy warunki PRE mogą zostać osiągnięte agent może dążyć do ich wypełnienia. Najczęściej agent musi znaleźć się w określonym miejscu, więc często ten stan manifestuje się jako przemieszczenie się do wybranego punktu (ang. \textit{go to}). 
    \item Gdy wszystkie warunki PRE są spełnione agent może przejść do realizacji zadania (ang. \textit{perform action}). 
\end{itemize}

Zaproponowana konwencja nie jest jedną, jednak wykorzystywaną w praktyce. Taki podział tworzy kilka możliwych podejść. 

Wymienione stany mogą stanowić bazę definiowanych działań, czyli każdy ze stanów wchodzi w skład interfejsu funkcji wywoływanej przy przejściach nadrzędnego . Mogą być nadrzędną maszyną stanów, 

\subsection{Problemy}

Tworzenie scenariuszy z użyciem automatów skończonych jest łatwe i niezawodne, w związku z czym zyskało dużą popularność przy sterowaniu agentami. Ma jednak swoje wady, ponieważ każdy możliwy scenariusz musi być przewidziany przez programistę. W grach komputerowych, ale szczególnie w robotyce społecznej przeoczenie przez programistę niektórych scenariuszy może prowadzić do nieoczekiwanego, nieintuicyjnego zachowania agenta. Liczba istniejących potencjalnie przejść między stanami jest kwadratem liczby stanów. Dodatkowo funkcje aktywowane przy uruchamianiu stanu mogą zawierać wewnętrzne zmienne, lub pobierać argumenty z zewnętrznego źródła. 

Inteligentny robot społeczny powinien być w stanie samodzielnie planować swoje akcje a nie polegać wyłącznie na gotowych scenariuszach, dlatego zasadne wydaje się zautomatyzowanie generowania automatów skończonych.


\section{Charakterystyka środowiska GOAP}

% GOAP Goal oriented action planning, (planowanie zadań zorientowane na cel) - 

GOAP to system planowania akcji, zaproponowany przez Jeffa Orkina w 2003 roku na potrzeby gry komputerowej F.E.A.R., którego podstawowe idee przedstawiono w \cite{ORKI}. 

\subsection{Elementy środowiska GOAP}


% GOAP przechowuje informacje o stanie świata, bądącą kolekcją 

% specjalnie do kontrolowania w czasie rzeczywistym autonomicznego zachowania postaci w grach. 

\subsection{GOAP a sterowanie agentami CERT}

\subsection{Zastosowania w grach komputerowych}

\subsection{Możliwość zastosowania w robotyce}

% GOAP dobrze sprawdza się w systemach wieloagentowych. 
% Pracuje w czasie rzeczywistym, dostosowuje się do zmiany środowiska, jednak bez dodatkowych elementów nie estymuje przyszłości i nie uwzględnia spontanicznych zmian w otaczającym świecie.
% 

\subsection{GOAP a model BDI}